var l=Object.defineProperty;var o=(t,a,r)=>a in t?l(t,a,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[a]=r;var u=(t,a,r)=>(o(t,typeof a!="symbol"?a+"":a,r),r);var p=Object.defineProperty,w=(t,a,r)=>a in t?p(t,a,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[a]=r,m=(t,a,r)=>(w(t,typeof a!="symbol"?a+"":a,r),r);function d(t,a){let r=0;const s=[];return async function(...i){await new Promise(c=>{r<a?(c(),r++):s.push(c)});try{return await t(...i)}finally{r--,r<a&&s.length!==0&&(s.shift()(),r++)}}}function g(t){return new Promise(a=>{if(typeof t=="number")setTimeout(a,t);else if(typeof t=="function"){const r=setInterval(()=>{t()&&(clearInterval(r),a())},100)}else a()})}var f=(t=>(t.Filter="filter",t.Map="map",t.ForEach="forEach",t.Reduce="reduce",t.FlatMap="flatMap",t))(f||{}),n=class{constructor(t,a){this.type=t,this.args=a,this.type=t,this.args=a}};m(n,"Type",f);var e=class{constructor(t){u(this,"tasks",[]);this.arr=t}static reduce(t,a,r){return t.reduce((s,i,c)=>s.then(h=>a(h,i,c)),Promise.resolve(r))}static map(t,a){return Promise.all(t.map((r,s)=>a(r,s)))}static async filter(t,a){const r=[];return await e.map(t,async(s,i)=>{await a(s,i)&&r.push(s)}),r}static async flatMap(t,a){return(await Promise.all(t.map((r,s)=>a(r,s)))).flatMap(r=>r)}static async forEach(t,a){await e.map(t,a)}map(t){return this.tasks.push(new n("map",[t])),this}flatMap(t){return this.tasks.push(new n("flatMap",[t])),this}filter(t){return this.tasks.push(new n("filter",[t])),this}async forEach(t){this.tasks.push(new n("map",[t])),await this}then(t,a){const r=this.value();return r.then(s=>(t&&t(r),s)).catch(s=>{throw a&&a(s),s}),r}async value(){let t=this.arr;for(const a of this.tasks)switch(a.type){case"filter":t=await e.filter(t,a.args[0]);break;case"map":t=await e.map(t,a.args[0]);break;case"flatMap":t=await e.flatMap(t,a.args[0]);break;case"forEach":await e.forEach(t,a.args[0]);return;case"reduce":return await e.reduce(t,a.args[0],a.args[1])}return t}};export{e as A,d as a,g as w};
